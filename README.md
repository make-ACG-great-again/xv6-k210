## xv6 on k210
这两天周末一直在研究往 k210 板子上移植 OS 的方案，下面把我这两天的思考整理一下。  
首先是 riscv-pk 往 k210 板子上移植的可能性，经过一番思考，最终得出的结论是不可行，理由如下：  
riscv-pk 中很多实现都是依赖于 host OS 来完成的，比如下面这个函数的实现：  
```C
static uintptr_t mcall_console_putchar(uint8_t ch)
{
  if (uart) {
    uart_putchar(ch);
  } else if (uart16550) {
    uart16550_putchar(ch);
  } else if (htif) {
    htif_console_putchar(ch);
  }
  return 0;
}
```
其中的`htif_console_putchar`函数最终会跳转到这样一个函数里面：`__set_tohost`。  
从名字就可以看出来了，这是将输出字符的请求传到 host OS 中去处理。  
再比如在 pk 代码中的系统调用，很大一部分是间接调用了这个函数：`frontend_syscall`，继续往下就是`htif_syscall`函数，再往下就是`do_tohost_fromhost`了。
很明显，这也是要到 hostos 里面去实现了。  
因此，pk 代码里面的很大一部分实现，都是通过 htif 机制转到 host OS 里面去实现。如果我们要在裸机上跑 pk 内核的话，我们没有 host OS 给 pk 提供服务。  
理论上我们可以封装一个“层”，用这个“层”的接口去替换 htif 接口，但是仔细想想这样的逻辑有点可笑：如果这个“层”可以做到提供 pk 代码需要的接口，那么实现这个“层”基本上已经等于实现一个 OS 内核了。  
事实上，riscv-pk 这个开源项目的设计思想就是为了可以在 host OS 上跑 riscv 程序，它将这个 riscv 程序的中断请求，系统调用都以一种机制转到 host OS 里面实现。这也是它为什么被称为“代理内核”的原因。  
结论：将 riscv-pk 移植到 k210 上基本没戏。  

然后我就着手去寻找一些适合往 k210 上移植的 OS，考虑过 seL4, RT-Thread 等等一些比较大的开源 OS，最终基于一些考虑选择了 xv6 这个 MIT 开发的教学 OS，理由如下：  
+ xv6 已经有了 riscv 版本，并且它可以在 qemu-system-riscv64 上稳定运行。
+ xv6 代码简洁，整体架构简单，移植过程可能比较顺利
+ xv6 代码注释齐全，有相关文档，我们可以比较容易地理解其中的实现
+ xv6 有个文件系统，虽然目前还不清楚这个文件系统是不是一个完整的文件系统

于是我就马上着手开始 xv6 往 k210 上移植的工作，经过一天多的努力，成果还算不错。  
首先讲一下将 xv6 往 k210 上移植的一些要点：  
+ xv6 在 qemu 上跑是没有用到 OpenSBI 的，它是在`start.c`里面实现了 bootloader 的功能。这个和早期 linux 版本有点像。在 xv6 里面，SBI 层和 OS 的界限有点模糊。
+ 我希望在将 xv6 移植到 k210 上的过程中用上 SBI 实现，将 M 态的 SBI 层和 S 态的 OS 层比较好地分隔。并且用 SBI 实现作为我们的 bootloader。
+ 这里简单说一下 SBI 的概念，SBI 其实是一 RISC-V 的标准，它运行在 M 态，向 OS 提供接口，SBI 有很多实现，目前国际 RISC-V 标准的实现列表里面有 OpenSBI,BBL,xvisor 等等，luojia 正在申请把他写的 RustSBI 加到这个列表里面。
+ 因此我们要用我们的 SBI 实现的 bootloader 功能替换 xv6 里面本身带有的 bootloader 实现，这个步骤听起来很简单，但是实际实现起来还是让我吃尽了苦头。

下面是我这几天移植 xv6 到 k210 过程在遇到的一些问题和踩的一些坑：  
+ xv6 的编译使用 riscv64-unknown-elf-gcc，如果你看过它的 Makefile，你会发现它的编译参数很多，它的链接参数也很多，这就导致我在工程搭建的过程中经常遇到不知道原因的报错
+ 在启动内核过程中我们非常关注 entry.S 和链接脚本这两个文件，它们直接影响到我们内核的启动，由于 xv6 原来是在 qemu 中运行的，再加上我们希望使用 SBI 实现来启动我们的内核，因此这两文件需要我们自己编写，而且在编写的过程中，我遇到的坑不少。经过几个小时的探索和参考 rCore-Tutorial 的启动过程，最终我写出了一个比较合适的版本，成功启动了 k210 的 两个核，并为每个核都分配了 4096 bytes 大小的启动栈。
+ 由于我们使用了 SBI 来启动我们的内核，而我们的 SBI 实现需要占据一定的内存空间，再考虑 k210 板子的实际情况，我们在 k210 上跑的内核的内存布局将会和原来的 xv6 内存布局不同。我们的内核被烧录到 k210 内存空间的物理地址是 0x80020000，可用的内存空间最大到 0x80600000。而 SBI 实现被烧录到 0x80000000 处。
+ 我非常推荐使用 RustSBI 而不是 OpenSBI，因为 RustSBI 遇到非法指令的时候，会报错并且指出非法指令地址，这样我们就可以通过将编译出来的内核镜像反汇编，然后跟踪到非法指令地址处进行 debug。OpenSBI 做不到这点
+ 理解内存布局对于移植 kalloc 模块和 vm 模块非常重要，我们需要在正确指定我们的内核结束地址和可用内存结束地址
+ 刷新 TLB。在 xv6 中，刷新 TLB 是用的`sfence.vma`指令，但是 k210 里面没有这个指令，正常情况下 RustSBI 会将这个指令翻译为 k210 旧版本的指令，但是好像没有奏效，内核会卡死。于是我就换成了`sfence.vm`这个旧版本指令，内核可以正常工作了，但是 TLB 有没有被正常刷新目前不确定，应该是正常刷新了吧。

下面总结一下目前的移植进展：  
+ 可以在 k210 板子上使用 RustSBI 进行多核启动了
+ 基于 RustSBI 提供的接口实现了 printf 等裸机上格式化输出函数
+ 实现了内存分配
+ 基本上实现了虚拟内存管理

以上实现还没有经过严格的测试验证，后续会添加测试模块来完善。  

下面补充几点:  
+ xv6 是个比较简单的 OS，我们最后可能不满足于仅仅把它移植到 k210 上去，正因为它简单，我们完善起来比较方便
+ xv6 是 MIT 的教学 OS，我觉得照搬别人的东西不是一个很好的选择，我希望能在移植工作完成后，对代码进行重构，模块化，使这个项目成为我们自己的东西。如果可能的话，它会成为我们学校的教学 OS。
+ 文件系统可能是个麻烦的问题，这部分会等到我们的内核移植得差不多了再来思考如何添加文件系统
+ 目前移植 xv6，不代表我们参赛就是用 xv6，这取决于我们后面的开发进展。只是目前移植 xv6 到 k210 上是我能想到的比较好的方案。
+ 关于软件调试环境的问题，我们可以封装一个hal层，这样我们就可以很方便地在各个软硬件平台上移植我们的内核代码。

写操作系统是个非常曲折和充满挑战性的过程，写出一个好的 OS 的秘诀，唯有坚持。  
